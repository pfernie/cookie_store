//! De/serialization via the Netscape cookie format

use crate::cookie_store::{CookieStore, StoreResult};
use crate::Cookie;
use cookie::{Cookie as RawCookie, Expiration as RawExpiration};
use std::fmt::Write as _;
use std::io::{BufRead, Write};
use time::OffsetDateTime;
use url::Url;

#[derive(Debug)]
pub struct NetscapeCookieError {
    message: &'static str,
}

impl NetscapeCookieError {
    fn msg(message: &'static str) -> Self {
        Self { message }
    }
}

impl std::fmt::Display for NetscapeCookieError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for NetscapeCookieError {}

fn parse_cookie_bool(input: &str) -> Result<bool, NetscapeCookieError> {
    match input {
        "TRUE" => Ok(true),
        "FALSE" => Ok(false),
        _ => Err(NetscapeCookieError::msg("invalid bool cookie part")),
    }
}

fn parse_cookie_line(line: &str) -> Result<Cookie<'static>, NetscapeCookieError> {
    let mut cookie_parts = line.split('\t');
    let domain = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;

    let subdomains = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;
    let subdomains = parse_cookie_bool(subdomains)?;
    if subdomains ^ domain.starts_with('.') {
        return Err(NetscapeCookieError::msg("cookie part conflict"));
    }

    let path = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;

    let secure = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;
    let secure = parse_cookie_bool(secure)?;

    let expires: i64 = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?
        .parse()
        .map_err(|_| NetscapeCookieError::msg("expires cookie part is not an integer"))?;
    let expires = match expires {
        0 => None,
        value => Some(OffsetDateTime::from_unix_timestamp(value).map_err(|_| {
            NetscapeCookieError::msg("expires cookie part could not be converted into a date")
        })?),
    };

    let name = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;

    let value = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;

    if cookie_parts.next().is_some() {
        return Err(NetscapeCookieError::msg("unexpected cookie part"));
    }

    let raw_cookie = RawCookie::build((name, value))
        .domain(domain)
        .path(path)
        .secure(secure)
        .expires(expires)
        .build();

    // Is there an easier way to build a cookie from a raw cookie here?
    let url_protocol = if secure { "https" } else { "http" };
    let url_domain = domain.strip_prefix('.').unwrap_or(domain);
    let url_raw = format!("{url_protocol}://{url_domain}");
    let url = Url::parse(&url_raw)
        .map_err(|_| NetscapeCookieError::msg("failed to create url from cookie"))?;

    let cookie = Cookie::try_from_raw_cookie(&raw_cookie, &url)
        .map_err(|_| NetscapeCookieError::msg("failed to convert raw cookie into cookie"))?;

    Ok(cookie.into_owned())
}

fn parse_cookies(input: &str) -> Result<Vec<Cookie<'static>>, NetscapeCookieError> {
    let mut cookies = Vec::new();
    for line in input.lines() {
        if line.starts_with('#') {
            continue;
        }
        if line.is_empty() {
            continue;
        }

        let cookie = parse_cookie_line(line)?;
        cookies.push(cookie);
    }
    Ok(cookies)
}

fn cookie_bool_str(value: bool) -> &'static str {
    if value {
        "TRUE"
    } else {
        "FALSE"
    }
}

fn write_cookies(cookies: &Vec<Cookie<'static>>) -> Result<String, NetscapeCookieError> {
    let mut output = String::new();
    writeln!(&mut output, "# Netscape HTTP Cookie File").unwrap();
    writeln!(
        &mut output,
        "# Generated by {} {}",
        env!("CARGO_CRATE_NAME"),
        env!("CARGO_PKG_VERSION"),
    )
    .unwrap();
    writeln!(&mut output).unwrap();

    for cookie in cookies.iter() {
        let cookie: &RawCookie = &*cookie;

        // TODO: Find a way to include the leading dot, if it exists.
        let domain = cookie.domain().ok_or(NetscapeCookieError::msg(
            "cannot serialize cookie with missing domain",
        ))?;
        // TODO: Figure out how to get this info from the cookie.
        let subdomains = cookie_bool_str(false);
        let path = cookie.path().unwrap_or("/");
        let secure = cookie_bool_str(cookie.secure().unwrap_or(false));
        let expires = match cookie.expires() {
            Some(RawExpiration::DateTime(datetime)) => datetime.unix_timestamp(),
            Some(RawExpiration::Session) | None => 0,
        };
        let name = cookie.name();
        let value = cookie.value();
        writeln!(
            &mut output,
            "{}\t{}\t{}\t{}\t{}\t{}\t{}",
            domain, subdomains, path, secure, expires, name, value,
        )
        .unwrap();
    }

    Ok(output)
}

/// Load Netscape-cookie-formatted cookies from `reader`, skipping any __expired__ cookies.
pub fn load<R: BufRead>(reader: R) -> StoreResult<CookieStore> {
    super::load(reader, parse_cookies)
}

/// Load Netscape-cookie-formatted cookies from `reader`, loading both __expired__ and __unexpired__ cookies.
pub fn load_all<R: BufRead>(reader: R) -> StoreResult<CookieStore> {
    super::load_all(reader, parse_cookies)
}

/// Serialize any __unexpired__ and __persistent__ cookies in the store to Netscape cookie format and
/// write them to `writer`.
pub fn save<W: Write>(cookie_store: &CookieStore, writer: &mut W) -> StoreResult<()> {
    super::save(cookie_store, writer, write_cookies)
}

/// Serialize all (including __expired__ and __non-persistent__) cookies in the store to Netscape cookie format and write them to `writer`.
pub fn save_incl_expired_and_nonpersistent<W: Write>(
    cookie_store: &CookieStore,
    writer: &mut W,
) -> StoreResult<()> {
    super::save_incl_expired_and_nonpersistent(cookie_store, writer, write_cookies)
}