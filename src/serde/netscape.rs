//! De/serialization via the Netscape cookie format
//!
//! # References
//! * https://curl.se/docs/http-cookies.html

use crate::cookie_store::{CookieStore, StoreResult};
use crate::Cookie;
use cookie::{Cookie as RawCookie, Expiration as RawExpiration};
use std::fmt::Write as _;
use std::io::{BufRead, Write};
use time::OffsetDateTime;
use url::Url;

#[derive(Debug)]
pub struct NetscapeCookieError {
    message: &'static str,
}

impl NetscapeCookieError {
    fn msg(message: &'static str) -> Self {
        Self { message }
    }
}

impl std::fmt::Display for NetscapeCookieError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for NetscapeCookieError {}

fn parse_cookie_bool(input: &str) -> Result<bool, NetscapeCookieError> {
    match input {
        "TRUE" => Ok(true),
        "FALSE" => Ok(false),
        _ => Err(NetscapeCookieError::msg("invalid bool cookie part")),
    }
}

fn parse_cookie_line(line: &str, http_only: bool) -> Result<Cookie<'static>, NetscapeCookieError> {
    let mut cookie_parts = line.split('\t');
    let domain = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;

    let subdomains = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;
    let subdomains = parse_cookie_bool(subdomains)?;
    if subdomains ^ domain.starts_with('.') {
        return Err(NetscapeCookieError::msg("cookie part conflict"));
    }

    let path = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;

    let secure = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;
    let secure = parse_cookie_bool(secure)?;

    let expires: i64 = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?
        .parse()
        .map_err(|_| NetscapeCookieError::msg("expires cookie part is not an integer"))?;
    let expires = match expires {
        0 => None,
        value => Some(OffsetDateTime::from_unix_timestamp(value).map_err(|_| {
            NetscapeCookieError::msg("expires cookie part could not be converted into a date")
        })?),
    };

    let name = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;

    let value = cookie_parts
        .next()
        .ok_or(NetscapeCookieError::msg("missing cookie part"))?;

    if cookie_parts.next().is_some() {
        return Err(NetscapeCookieError::msg("unexpected cookie part"));
    }

    let mut raw_cookie_builder = RawCookie::build((name, value));
    if http_only {
        raw_cookie_builder = raw_cookie_builder.http_only(http_only);
    }
    let raw_cookie = raw_cookie_builder
        .domain(domain)
        .path(path)
        .secure(secure)
        .expires(expires)
        .build();

    // Is there an easier way to build a cookie from a raw cookie here?
    let url_protocol = if secure { "https" } else { "http" };
    let url_domain = domain.strip_prefix('.').unwrap_or(domain);
    let url_raw = format!("{url_protocol}://{url_domain}");
    let url = Url::parse(&url_raw)
        .map_err(|_| NetscapeCookieError::msg("failed to create url from cookie"))?;

    let cookie = Cookie::try_from_raw_cookie(&raw_cookie, &url)
        .map_err(|_| NetscapeCookieError::msg("failed to convert raw cookie into cookie"))?;

    Ok(cookie.into_owned())
}

fn parse_cookies(input: &str) -> Result<Vec<Cookie<'static>>, NetscapeCookieError> {
    let mut cookies = Vec::new();
    for mut line in input.lines() {
        let mut http_only = false;
        if let Some(trimmed) = line.strip_prefix("#HttpOnly_") {
            line = trimmed;
            http_only = true;
        } else if line.starts_with('#') || line.is_empty() {
            continue;
        }

        let cookie = parse_cookie_line(line, http_only)?;
        cookies.push(cookie);
    }
    Ok(cookies)
}

fn cookie_bool_str(value: bool) -> &'static str {
    if value {
        "TRUE"
    } else {
        "FALSE"
    }
}

fn write_cookies(cookies: &Vec<Cookie<'static>>) -> Result<String, NetscapeCookieError> {
    let mut output = String::new();
    writeln!(&mut output, "# Netscape HTTP Cookie File").unwrap();
    writeln!(
        &mut output,
        "# Generated by {} {}",
        env!("CARGO_CRATE_NAME"),
        env!("CARGO_PKG_VERSION"),
    )
    .unwrap();
    writeln!(&mut output).unwrap();

    for cookie in cookies.iter() {
        let cookie: &RawCookie = &*cookie;

        // TODO: Find a way to include the leading dot, if it exists.
        let domain = cookie.domain().ok_or(NetscapeCookieError::msg(
            "cannot serialize cookie with missing domain",
        ))?;
        // TODO: Figure out how to get this info from the cookie.
        let subdomains = cookie_bool_str(false);
        let path = cookie.path().unwrap_or("/");
        let secure = cookie_bool_str(cookie.secure().unwrap_or(false));
        let expires = match cookie.expires() {
            Some(RawExpiration::DateTime(datetime)) => datetime.unix_timestamp(),
            Some(RawExpiration::Session) | None => 0,
        };
        let name = cookie.name();
        let value = cookie.value();
        if cookie.http_only() == Some(true) {
            write!(&mut output, "#HttpOnly_").unwrap();
        }
        writeln!(
            &mut output,
            "{}\t{}\t{}\t{}\t{}\t{}\t{}",
            domain, subdomains, path, secure, expires, name, value,
        )
        .unwrap();
    }

    Ok(output)
}

/// Load Netscape-cookie-formatted cookies from `reader`, skipping any __expired__ cookies.
pub fn load<R: BufRead>(reader: R) -> StoreResult<CookieStore> {
    super::load(reader, parse_cookies)
}

/// Load Netscape-cookie-formatted cookies from `reader`, loading both __expired__ and __unexpired__ cookies.
pub fn load_all<R: BufRead>(reader: R) -> StoreResult<CookieStore> {
    super::load_all(reader, parse_cookies)
}

/// Serialize any __unexpired__ and __persistent__ cookies in the store to Netscape cookie format and
/// write them to `writer`.
pub fn save<W: Write>(cookie_store: &CookieStore, writer: &mut W) -> StoreResult<()> {
    super::save(cookie_store, writer, write_cookies)
}

/// Serialize all (including __expired__ and __non-persistent__) cookies in the store to Netscape cookie format and write them to `writer`.
pub fn save_incl_expired_and_nonpersistent<W: Write>(
    cookie_store: &CookieStore,
    writer: &mut W,
) -> StoreResult<()> {
    super::save_incl_expired_and_nonpersistent(cookie_store, writer, write_cookies)
}

#[cfg(test)]
mod test {
    use super::*;

    const HTTP_ONLY_COOKIE_LINE: &str =
        "#HttpOnly_.example.com	TRUE	/	TRUE	0	cookie-name	cookie-value\n";

    #[test]
    fn read_http_only_cookie() {
        let cookie_store = load_all(HTTP_ONLY_COOKIE_LINE.as_bytes()).expect("failed to parse");
        assert!(cookie_store.iter_any().count() == 1);

        let cookie = cookie_store.iter_any().next().expect("missing cookie");

        assert!(cookie.http_only() == Some(true));

        let domain = cookie.domain.as_cow().expect("missing domain");
        assert!(domain == "example.com");

        let path = cookie.path().expect("missing path");
        assert!(path == "/");

        assert!(cookie.secure() == Some(true));

        let expires = cookie.expires().expect("missing expires");
        assert!(expires.is_session());

        assert!(cookie.name() == "cookie-name");
        assert!(cookie.value() == "cookie-value");
    }

    // TODO: This test is ignored as it fails since we don't properly handle the leading . for domains.
    #[test]
    #[ignore]
    fn write_http_only_cookie() {
        let mut cookie_store = CookieStore::default();
        let cookie = RawCookie::build(("cookie-name", "cookie-value"))
            .http_only(true)
            .domain("example.com")
            .path("/")
            .secure(true)
            .expires(RawExpiration::Session)
            .build();
        let url_raw = format!("https://example.com/");
        let url = Url::parse(&url_raw).expect("failed to parse url");
        cookie_store
            .insert_raw(&cookie, &url)
            .expect("failed to insert cookie");

        let mut output = Vec::new();
        save_incl_expired_and_nonpersistent(&cookie_store, &mut output)
            .expect("failed to save cookies");
        let output_string = String::from_utf8(output).expect("output is not utf8");

        let has_cookie_line = output_string
            .lines()
            .any(|line| line == HTTP_ONLY_COOKIE_LINE.trim_end());
        assert!(
            has_cookie_line,
            "Missing cookie line:\n{HTTP_ONLY_COOKIE_LINE}\n\nOutput:\n{output_string}"
        );
    }
}
